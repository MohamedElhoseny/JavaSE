  # How to Make Server Application That doesnt have to define Jobs that it executes ??


    There Are Many Restriction :
            1- Class of jobs must implements an interface defined by Server
            2- Class of jobs is Send by Client Through the Socket
            3- To return Result from Server , Server will Send Result Class to Client
            4- Result Class Object must implement interface defined by Client

     (1) Writing The Server :
            Server Application consists of three parts :
             -Result interface        ( this interface implementation on server )
             -Executable interface    ( it provides a description of what methods a job should implement )
             -Main file               ( that accepts and executes the jobs submitted by the client)


           -> Client Create a job Object implementing this interface and submits it (using Object Serialization) for executation
           -> Server Restores the job Object and invokes a Method defined in the Executable interface (that the job object implement them in Client side)


============================= ===================  Writing and implementing Interfaces  =================== ==========================================

        1) Executable interface :
              //simple Code
           public interface Executable
           {
              public String execute();  //hold Job Code
           }
              => The Server will invoke it in the job object that submits by the Clients and Create Result object and send back to the Client

        2) Result interface :
             //simple Code
           public interface Result
           {
               public String output();
               public double CompleteTime();
           }
             => The Result Object's Class Must implement this interface and The Client Must get this Result Object's Class definition to get the result

         Note That
         _________
            - Since Executable and Result are exchanged (wa7d byro7 we wa7d byege) using java object Serialization interface So Classes that implements
               those interfaces Must also implements Serializable interface (deep Serialization Concept)

          ============= ==================  Writing Classes that implements interfaces  =================== =============

           1] Server only Define one Class "Resultimp.java" which implements Result interface
                 //Simple Code
               public class Resultimp implements Result , Serializable
               {
                   String output;
                   double completetime;

                   public Resultimp(String o ,double c)
                   {
                       this.output = o;
                       this.completetime = c;
                   }

                   @Override
                   public String output()
                   {
                      return this.output;
                   }
                   public double CompleteTime()
                   {
                      return this.completetime;
                   }

               }

              => The object of this class represent the result of a job , this object generated by a job at serverEnd and will transferred to ClientSide
                 To reConstruct the result Object  to Work with the Result


             2] Client only One Class "job.java" which implements Executable interface
                  //Simple Code
                public Class Job implements Executable , Serializable
                {
                    @Override
                    public String execute()
                    {
                        //code of job that the server will Have to Do
                         int n = 5, prod = 1;
                         for(int i=2; i<=n; i++)
                         {
                            prod *= i;
                         }
                         return (new Integer(prod)).toString();
                    }
                }

               => A Job Object submitted By Client is Transferred to the ServerSide , So the ServerSide will reConstract "readObject" the Job Object


    ====================================== Implementing Server and Client ============================================

     [1] Implementing Server

         public Class TCPServer
         {
             public static void main(String[] args) throws IOException
             {
                 ServerSocket serverSocket = new ServerSocket(6001);
                 Socket ServerEnd = serverSocket.accept();
                    => Request Accepted !

                 ObjectInputStream fromClient = new ObjectInputStream(ServerEnd.getInputStream());
                 String ClassFile = (String)fromClient.readObject();    //FileName of Job Class which implement Executable interface
                 byte[] b = (byte[])fromClient.readObject();           //Read Job Class Implementation

                 FileOutputStream Job_File = new FileOutputStream(ClassFile);      //Create File with Name "Job.class"
                 Job_File.write(b);          //Write Job Class implementation

                 Executable ex = (Executable)fromClient.readObject();       //Read Job Class Object

                 double Start_time = System.nanoTime();
                 String output = ex.execute();            //Fire the execute Method in Job Class Object
                 double End_time = System.nanoTime();
                 double Compelete_time = End_time - Start_time;

                 Resultimp r = new Resultimp(output,Complete_time);    //Create Object from Server buit-in Resultimp Class

                 ObjectOutputStream toClient = new ObjectOutputStream(ServerEnd.getOutputStream());
                 ClassFile = "Resultimp.class";
                 toClient.writeObject(ClassFile);       //Send Result ClassName to Client to Construct it

                 //Read implementations in Result Class to Send to Client to put it in Constructed Class
                 FileInputStream Result_File = new FileInputStream(ClassFile);
                 byte[] bb = new byte[Result_File.available()];    //to set size of bytes of array to read
                 Result_File.read(bb);

                 toClient.writeObject(bb);     //Send Result implementation
                 toClient.writeObject(r);     //Send Result object to Client

                 ServerEnd.close();
             }
         }


 /  Brief of What's the Server Do ?
     => Get Job Class Name and Create a File with same Name then read bytes of Job class implementation from Client and Write them in the New File in Server
     => Reconstruct Job Object and Call execute() method in it to Make the Job Done
     => Create a Result class Object and Send Job output data to it to store them
     => Send Result class name and its Implementation's Byte to Client  then Send the Result object to Client to reConstruct it and read Result data
        ( Get Job Class and Read its Object , Run job Object Executation  , Build Result object & intialize it then Send Result Class and its Object to Client)

       [2] Implementing Client

          public Class TCPClient
          {
             public static void main(String[] args) throws IOException
             {
                Socket ClientEnd = new Socket("localhost",6001);
                  => Send Request

                 ObjectOutputStream toServer = new ObjectOutputStream(ClientEnd.getOutputStream);
                  String ClassFile = "Job.class";
                  toServer.writeObject(ClassFile);   //Send to Server The Name Of Class That have The Job (Server Work)

                 FileInputStream Job_File = new FileInputStream(ClassFile);     //Open File with name Job.class
                 byte[] b = new byte[Job_File.available()];        //set size of byte array corresponding to File byte Size
                 Job_File.read(b);            //read all bytes in file and Store them in array of bytes
                 toServer.writeObject(b);     //Send array of byte to Server (implementation of Job Class)  to Reconstract this Class

                 Job  Server_Job = new Job();            //Create Job Object and Send it to Server
                 toServer.writeObject(Server_Job);

                 ObjectInputStream fromServer = new ObjectInputStream(ClientEnd.getInputStream);    //Start read from Server
                 ClassFile = (String)fromServer.readObject();        //Server Send Me ClassFile => Resultimp

                 b = (byte[]) fromServer.readObject();     //read array of bytes from Server (Resultimp implementation)
                 FileOutputStream Result_File = new FileOutputStream(ClassFile);     //create file in ClientSide with name Resultimp
                 Result_File.write(b);      //Write its implementation

                 Result r = (Result)fromServer.readObject();     //Create Object from this Class
                 => used Now Object r and access it to Get result and anything we want

                 ClientEnd.close();
             }
          }


    /  Brief of What's the Client Do ?
      => Send Job Class Name and Implementation's bytes to the Server
      => Create Object From Job and Send it to Server To use it to fire execute method to do job
      => Recieve Result class name and Implementation's byte from Server and Make it
      => Read the Result Object from Server to Make object refer to it to use its method to get data
         (Send Job Class and Object from it , Recieve Result Class and Create Object from it , Read Data from Result object )
























